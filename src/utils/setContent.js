import Skeleton from "../components/skeleton/Skeleton";
import Spinner from "../components/spinner/spinner";
import ErrorMessage from "../components/errorMessage/ErrorMessage";

const setContent = (process, Companent, data) => {
    switch (process) {
        case 'waiting':
            return <Skeleton/>; // break погас потому что функция встречает ключевое слово return
            break;              // но если return не будет то break надо прописывать потому что код просто дальше пойдет по кейсам
        case 'loading':
            return <Spinner/>;
            break;
        case 'confirmed':
            // return <View char={char}/>;
            return <Companent data={data}/>;
            break;
        case 'error':
            return <ErrorMessage/>;
            break;
        default: // если не один кейс не выполнился то выбрасываем новый конструктор ошибки new Error() с сообщением
            throw new Error('Unexpected process state'); 
    }
}

export default setContent;

// Lesson 187 Принцип конечного автомата (FSM, Finite-state machine)

// в компаненте CharInfo в зависимости от состояния рендерим разный интерфейс

// вот этот код 

    // const sceleton = char || loading || error ? null : <Skeleton/>;
    // const errorMessage = error ? <ErrorMessage/> : null;
    // const spinner = loading ? <Spinner/> : null;
    // const content = !(loading || error || !char) ? <View char={char}/> : null;

// иногда такой подход называют антипаттерным из за сложности логики преобразований особенно в строках sceleton и content
// в случае с errorMessage или spinner всего 2 состояния true или false
// но в случае с sceleton и content уже 2 в 3 степени от которых зависит рендер компанента View и плюс они могут еще разрастаться

// в приложения такое случается часто не только с формированием контента 
// на примере кнопки оно может быть в разных состояниях например она скрыта, задизейблена, с разным текстом внутри, в фокусе, нажата и тд.
// что бы не прописывать для всех состояний условия существует концепция конечного автомата
// говоря простыми словами это такая сущность каторая имеет определенное количество состояний
// на примере кнопки эта сужность конечный автомат в один момент времени может содержать только одно активное состояние если кнопка скрыта
// то она не может быть выключена и наоборот
// и для того что бы что то сделать с этим элиментом надо поменять его состояние 

// напримере кнопки в зависимости от ее состояния 
// если она скрыта то с ней ничего сделать нельзя ее нет на странице
// если она задизейблена при нажатии ничего не происходит
// если она в фокусе то с ней она делает какие то действия
// и тд. это и есть концепция конечного автомата

// конечный авомат это математическая модель каторая применяется много где в програмировании
// в искуственном интеллекте в играх и в фронте в реакте
// само название FSM Finite-state machine поэтому еще называют стейт машины
// если вооще придераться то любое приложение или участок кода каторое использует состояние можно назвать стейт машиной
// только используется лишь часть концепции

// стейт машины могут реализовываться поразному код и подход может быть разный это концепция а не какйто конкретный прием или техника
// главное что бы соблюдались базовые принципы конечное количество состояний, механизм перехода, удобный функционал отображения, одно активное
// состояние
// в компаненте CharInfo 
// конечное количество состояний loading error char
// механизм перехода когда происходит запрос идет переключения loading error или загружается char или ничего не произошло и рендериться sceleton
// одно активное состояние прописано 4 строками выше
// нет только удобного  функционала отображения 

// есть гтовые библиотеки machina-js XState и Robot

// в http.hook.js создаим еще одно состояние process поумолчанию оно будет 'waiting'
// как только запуститься функция request пойдет запрос process будет перехдить в 'loading'
// есть такое соглашение что состояние в конечных автоматах надо прописывать строками а не булиновыми значениями это связано с бекендом и 
// базами данных
// когда запрос завершен process будет перехдить в 'confirmed'
// в catch если произошла ошибка то process будет перехдить в 'error'
// в функции clearError каторая очищает ошибки process будет перехдить в 'loading'
// и process прописываем в экспорт и в MarvelService импортруем и прописываем в экспорт что бы прокидывать в другие компаненты

// в компаненте CharInfo импортруем process
// создадим функцию setContent катрая будет принимать 2 аргумента process и char - то что передается в компанент View
// но такая структура работать не будет из за асинхронности кода в MarvelService
// когда данные получены от сервера в http.hook.js process будет перехдить в 'confirmed' но далше данные экспортируются return data; 
// в MarvelService в переменную res и дальше идут на обработку в _transformCharacter и пока все эти действия пройдут пройдет время а мы 
// уже поставили process в 'confirmed' и реакт будет пытаться отрендерить <View char={char}/> с данными каторые еще не пришли с переработки
// что бы такова не случалось передадим функцию по ручному изменению состояния setProcess в сам компанент 
// прокидываем setProcess из http.hook.js в MarvelService и далше в CharInfo
// в CharInfo process будет перехдить в 'confirmed' когда данные уже загружены и будут переходить в текущий стейт в методе getCharacters
// теперь в CharInfo в return проссто вызываем setContent с process и текущим стейтом char

// теперь код стал намного проще в логическом понимании, переменные loading, error уже не нужны их заменяет process
// но функцию setContent придется повторять во всех таких компанентах тут от ситуации но стараются писать такие копаненты с похожей логикой
// ее можно вынеси в отдельный файл и импорровать по надобности подставляя нужные аргуенты
// но если логика компанента отличается то такую функцию придется прописывать для конкретного компанента подстраиваясь под его логику

// еще можно поместить setContent в http.hook.js то тогда этот файл дополнится логикой каторая не совсем относится к логике хука

// создаим такую функцию setContent в отдельном файле setContent.js
// на месте компанента View будет универсальный Companent каторй будет приходить как аргумент, char тоже меняем на data приходит как аргумент

// импортируем setContent в CharInfo там уже Skeleton Spinner ErrorMessage уже не нужны и вызываем setContent с аргументом View



// сделаем тоже самое с CharList импортируем туда setContent и process, setProcess из MarvelService
// логика почти точна такая же помеещаем .then(() => setProcess('confirmed')) в метод getAllCharacters после загрузки данных
// вместо компанента View сдесь есть переменная items каторая формируется из функции renderItems
// поэтому в setContent как аргумент компанент передаем функцию setContent(process, () => renderItems(charList))
// так как функциональный компанент это функция каторая возвращает какие то реакт элименты
// 3 аргумент не передаем он просто будет андефайнд
// но теперь немного поламалась логика компанента при подгрузке новых персонажей все персонажи исчезают появляется спинер после 
// появляются все персонажи с подгруженными такое уже было
// поэтому сдесь прдется напсать собственную функцию setContent для этого компанента с учетом состояния newItemLoading

// тоже самое сделаем в ComicsList

// тоже самое сделаем в RandomChar но у него обычная логика как и у CharInfo

// тоже самое сделаем в SinglePage что и в RandomChar

// сейчас loading, error используются только в CharSearchForm там тоже можно переделать по такому шаблону