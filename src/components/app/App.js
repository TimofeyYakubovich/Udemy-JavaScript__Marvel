// import { useState } from "react";
import { lazy, Suspense } from "react";
import { BrowserRouter as Router, Route, Switch} from "react-router-dom";
// import { MainPage, ComicsPage, SingleComicPage } from "../pages";
// такой прием удобен когда мног страниц все импортировать в один файл после экспортируем как один объект
// это позволяет все страници импортировать одной строчкой я не отдельно по строке на каждую страницу
// не указываем из какова файла вообще импотрируем эти страници потому что если вебпек видет бращение просто к папке ../pages то он ищет
// то он пытается найти в этой папке файлик index.js если он его не найдет то будет ошибка если найдет то импортирует

import AppHeader from "../appHeader/AppHeader";
import Spinner from "../spinner/spinner";

const Page404 = lazy(() => import('../pages/404'))
const MainPage = lazy(() => import('../pages/MainPage'))
const ComicsPage = lazy(() => import('../pages/ComicsPage'))
const SingleComicPage = lazy(() => import('../pages/SIngleComicPage'))

// import RandomChar from "../randomChar/RandomChar";
// import CharList from "../charList/CharList";
// import CharInfo from "../charInfo/CharInfo";
// import ErrorBoundary from "../errorBoundary/ErrorBoundary";

// import decoration from '../../resources/img/vision.png';
// import AppBanner from "../appBanner/AppBanner";
// import ComicsList from "../comicsList/ComicsList";

// Lesson 174 
// маршрутизация или роутинг в веб приложениях
// в клсическом сайте каждая страница это php или html файл каторый отвечает за определенный адрес URL
// в веб приложения на месте старой страници создается новый интерфейс с помощью JS без перезагрузки страници
// за роутинг отвечает отдельная библиотека React Router
// устанавливаем библиотеку npm i react-router-dom@5.3.0
// основными единицами библитеки яляются 4 компанента

// 1 BrowserRouter бычно переименовывают в Router ключевой компанент каторый обарачивает все сслыки и страници (маршруты) по каторым переходит пользователь
// помещаем все копаненты в компанент Router для того что бы были рабочими все ссылкки и все страници внутри одного компанента Router
// Router посути такой Маршрутизатор каторый получает сигналы от ссылок и показывает нужную нам страницу

// 2 Route маршрут Route именно этот компанент Route будет грузиться если в url адресе появится определенная ссылка
// атрибут path какой url адрес будет отслеживать маршрут Route / - главная страница

// в приложениях часто необходимо комбинировать разные компаненты например загрузить главную страницу но при выбре пользователя каторый сопровождается
// изминением юрл адреса необходимо подгрузить компанент с подробным описанием пользователя и поместить его тоже на главную страницу это называетя
// компазиция и библиотека react-router позволяет это делать но тогда вылазит другой момент по пути path="/comics"> загрузяться обе страници

// 3 Switch библиотека react-router сравнивает строку в path не строго что в ней написано а почастям
// поэтому без компанента Switch по пути path="/"> откроется только главная страница а по пути path="/comics"> откроется и главная и страница
// с комиксами вместе потому что в пути path="/comics"> входит просто /
// что бы такова не случалось нужен компнент Switch каторый загружает один подходящий компанент

// в таком случае при пути path="/comics"> подгружается не страница комиксов а главная страница все потому что Switch смотрит на детей каторые есть
// внутри него на маршруты и рендерит только первый каторый идет по совпадениб с юрл и так как в path="/"> / совпадает с path="/comics"> он грузит
// главную страницу при этом Switch не смотрит что дальше есть еще маршруты в которых есть юрл со слешом и грузит только первую по совпадению

// если поменять Route местами то по пути path="/comics"> подгрузится одна страница с комиксами так как она первая совпадает но по пути path="/">
// подгружается уже главная страница
// атрибут exact говорит что только полное совпадение пути будет рендерить этот компанент

// 4 Link компанент ссылка заменяет <a> и href тоже надо заменить на атрибут to=""

// компанент <Redirect/> может перенаправлять пользователя по определенному адресу в зависимсоти от условия
// {loggedIn ? <Redirect to="/dashboard" /> : <PublicHomePage />}

// компанент NavLink почти тоже самое что и Link но у него есть возможность стилизации активной ссылки
// допустим подвечивать на какой старнице сейчс находится пользователь
// его атрибут activeStyle задает объект со стилями каторые будут применены к активной ссылке
// прописывать в формате инлайн стилей тоесть передаем объект activeStyle={{'color': '#9f0013'}}
// приминЯется с атрибутом exact для того что бы небыло окрашивания по нечеткому сравнению путей path так как вторая страница тоже содержит /
// атрибут activeClassName класс каторый будет добавляться к активной ссылке

const App = () => {

    // const [selectedChar, setChar] = useState(null);
    
    // const onCharSelected = (id) => { 
    //     setChar(id);
    // }

    return (
        // <Router>
        //     <div className="app">
        //         <AppHeader/>
        //         <main>
        //             <Switch>
        //                 <Route exact path="/">
        //                     <ErrorBoundary>
        //                         <RandomChar/>
        //                     </ErrorBoundary>
        //                     <div className="char__content">
        //                         <ErrorBoundary>
        //                             <CharList onCharSelected={onCharSelected}/>
        //                         </ErrorBoundary>
        //                         <ErrorBoundary>
        //                             <CharInfo charId={selectedChar}/>
        //                         </ErrorBoundary>
        //                     </div>
        //                     <img className="bg-decoration" src={decoration} alt="vision"/>
        //                 </Route>
        //                 <Route exact path="/comics">
        //                     <AppBanner/>
        //                     <ComicsList/>
        //                 </Route>
        //             </Switch>
        //         </main>
        //     </div>
        // </Router>

        // разделим код на отдельные страници для удобства обычно для этого внутри проекта в папке components создают папку pages
        <Router>
            <div className="app">
                <AppHeader/>
                <main>
                    <Suspense fallback={<Spinner/>}>
                        <Switch>
                            <Route exact path="/">
                                <MainPage/>
                            </Route>
                            <Route exact path="/comics">
                                <ComicsPage/>
                            </Route>
                            <Route exact path="/comics/:comicId">
                                {/* сдесь в юрл после /comics указываем уникальный идентификатор название придумываем сами
                                это будет айдишка каждого отдельного комикса */}
                                <SingleComicPage/>
                            </Route>
                            <Route path="*">
                                <Page404/>
                            </Route>
                        </Switch>
                    </Suspense>
                </main>
            </div>
        </Router>
    )
}

// Lesson 176
// в реакте есть свой способ реализовывать динамическую подгрузку компанентов еще она может называться ленивой подгрузкой
// это реализовывает метод React.lazy() этот метод будет загружать компанент только тогда когда он впервые отрендерен
// тоесть зашел пользователь на страницу /comics и только тогда когда он туда зашел этот компанент будет подгружаться в общий скрипт
// копанент каторый будет ленива подгружаться должен быть обезательно экспортирован поумолчанию export default

// лениво подгрузи страницу 404 для этого вынесем ее в отдельный импорт потому что щас в index.js она экспортируется иминованым экспортом
// экспортируем мемтод lazy из реакта он использует внутри колбек функцию каторая подгружает компаненты
// все динамические импорты должны подгружаться после статических
// динамический импорт страници 404 const Page404 = lazy(() => import('../pages/404')) теперь она будет подгружаться только тогда когда он
// действительно появится на странице
// в обычном js ошибки обрабатываются через блок кода catch то в реакте это делает тдельный компанент Suspense он отвечает за ошибки в импортах
// и отображении запасного содиржимого
// обычно оборачивают все страници в компанент Suspense у него есть обязательный атрибут fallback в него помещается то что можно показать пока
// грузится динамический импорт
// сделаем все остальные старници ленивыми
// главную старницу тоже можно сделать ленивой потому что пользователи часто заходят не на главную страницу а сразу на какую то староннию
// файлик index.js оставим на случай если где то придется статически импортировать какую то страницу
// лениво можно грузить и отдельные компаненты на страницах




// Lesson 175
// если в приложении пользователь начнет переходить на не существующую страницу например http://localhost:3000/gtdthfgdh то крооме шапкии
// ничего подгружаться не будет происходит это потому что нет ни одного совпадение по роутам в рутере потому что везде стоит атрибут exact
// что бы это пофиксить есть 2 варианта

// если мы хотим что бы на любой неправильный юрл отображалась главна страница то помещаем главный Route вконец и удлаяем атрибут exact
// потому что Switch если нет атрибута exact смотрит на детей каторые есть внутри него на маршруты и рендерит только первый 
// каторый идет по совпадениб с юрл

// но в реальных приложениях чаще всего нужно отобразить специальную 404 страницу
// для этого последним компанентом нужно сдедать роут каторый будет вести на * <Route path="*"> и внутри будет компанент каторый будет 
// отображать 404 страницу или другой компанент
// дослвно это значит что если не подошел не один path то загрузится path="*"
// создадим внутри pages 404.js


export default App;

// this.updateChar(); делать сетевой запрос в кострукторе во врея конструирования класса это плохая практика

// сделаем так что бы клмпанент View можно было показывать или удалять со страници динамически с конопки
// а теперь сделаем что бы этот компанент будет обнавляться каждые 3 секунды с показом нового персонажа и выводить console.log('upDate');
// теперь через каждые 3 секунды приходит 2 upDate потому что идёт 2 заапроса 
// при этом при нажатии на CLick me компанент удаляется но запросы всёравно идут по 2 раза
// есл несколько раз пересоздать компанент нажатием CLick me то каличество запросов стремительно растёт потому что растёт количество
// бывшесозданных компанентов и каждый делает по 2 запроса
// всё потому что мы негде не прописали clearInterval и в каждом бывшесозданном компаненте setInterval бесконечно продалжает работать
// это плохо во первых потому что идут лишние запросы если компанент будет исчезать и появляться то запросов накопится много и 
// браузер может завснуть
// 2 причина в JS если есть ссылка на какой то объект setInterval(this.updateChar, 3000) то он из памяти не удаляется и в таком
// случаем каждый старый компанент сохраняется в памяти на нем есть ссылка это назыается утечкой памяти
// таки вопрос в каком месте компанента прописывать clearInterval

// Жизненный цикл компонентов 
// 3 этапа
// на каждом из этапов можно вызвать определенные функции хуки жизненного цикла


// 1 компанент появляется на странице (Монтирование)
// хук componentDidMount()
// путь жизненного цикла, что зачем вызывается при создании (Монтировании) компанента на странице
// 1 вызывается constructor
// 2 вызывается render() рендерится верстка
// 3 React обновляет DOM сруктуру и рефы
// 4 вызывается хук componentDidMount()


// 2 компанент может обнавляться 2 спосабами new props, setState, команда позволяющая насильно обновить компанент forceUpdate()
// если компанент получает новое свойство new props он перерисовывается обнавляется
// если внутри компанента был изменён state через setState он тоже перерисовывается обнавляется
// хук componentDidUpdate()
// путь жизненного цикла, что зачем вызывается при обновлении компанента на странице
// 1 вызывается render() рендерится верстка
// 2 React обновляет DOM сруктуру и рефы
// 3 вызывается хук componentDidUpdate()

// 3 компанент удаляется со страницы
// хук componentWillUnmount()
// путь жизненного цикла, что зачем вызывается при удалении (Размонтировании) компанента со страници
// 1 вызывается хук componentWillUnmount()


// есть еще 4 этап ошибки когда в компаненте случается ошибка
// хук componentDidCatch()


// проведем эксперемент на каждом этапе вызовем console.log()
// получаем последовательно в консоль constructor render mount нажимаем CLick me получаем unmount 
// нажимаем еще раз CLick me получаем constructor render mount значит хуки работают последовательно

// почему происходит 2 запроса на сервер, запрос мы делали в конструкторе
// в таком случаем в консоль выдаёт constructor render mount upDate upDate render Update 
// из за того что запрос делали в конструкторе реакт делал запрос сначала в конструкторе получал данные но засунут ьих еще некуда потому
// что метод render еще не запущен, потом когда уже доходил до метода render делал запрос еще раз и уже нормально помещал их на страницу

// использовать обновления можно только на этапе коммита тоесть только в 3 онсновных хуках 
// componentDidMount() componentDidUpdate() componentWillUnmount() 
// поэтому лучше всего вызвать обращение к серверу в componentDidMount()
// теперь получаем в консоль constructor render mount upDate render Update 

// есл ипрописывать setInterval в componentDidMount() то в componentWillUnmount() его нужно останавливать clearInterval
// в таком случаем в консоль выдаёт constructor render mount и каждые 3 секунды upDate render Update
// нажимаем CLick me получаем в консоль unmount и запросы больше не идут потому что мы их остановили в componentWillUnmount()
// нажимаем еще раз CLick me получаем тоже поведение constructor render mount и каждые 3 секунды upDate render Update

// также надо удалаять и addEventListener через removeEventListener
